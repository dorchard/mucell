/* Cathy Young
 * 
 * Classes representing a whole SBML model
 * Latest SBML spec: http://belnet.dl.sourceforge.net/sourceforge/sbml/sbml-level-2-version-3-rel-1.pdf
 */

using System;
using System.Xml.Serialization;
using System.Collections.Generic;

namespace MuCell.Model.SBML
{
    /// <summary>
    /// A non-leaf node in a MathTree. Holds a mathematical operator
    /// and a subtree
    /// </summary>
    public class InnerNode : MathNode
    {
        //[XmlElement(IsNullable=true)]
        [XmlElement(Type=typeof(InnerNode))]
        [XmlElement(Type=typeof(LeafNode))]
        [XmlElement(Type=typeof(ReferenceLeafNode))]
        [XmlElement(Type=typeof(NumberLeafNode))]
        public List<MathNode> subtree;

        // Store the arity of the operator
        private int arity;
        //[XmlElement("innerNode",Type=typeof(BinaryLogicOperators))]
        //[XmlElement("innerNode", Type = typeof(BinaryMathOperators))]
        //[XmlElement("innerNode", Type = typeof(UnaryLogicOperators))]
        //[XmlElement("innerNode", Type = typeof(UnaryMathOperators))]
        [XmlIgnore]
        public Enum data;

        [XmlElement]
        public String Data
        {
            get
            {
                return this.data.ToString();
            }
            set { }
        }

		/// <summary>
		/// Primary constructor
		/// </summary>
        public InnerNode()
        {
            this.subtree = new List<MathNode>();
            this.arity = 0;
        }

        public InnerNode(BinaryLogicOperators op)
        {
            this.subtree = new List<MathNode>();
            this.data = op;
			this.arity = 2;
        }
        
       	public InnerNode(BinaryMathOperators op)
        {
            this.subtree = new List<MathNode>();
            this.data = op;
			this.arity = 2;
        }
   
        public InnerNode(UnaryLogicOperators op)
        {
            this.subtree = new List<MathNode>();
            this.data = op;
			this.arity = 1;
        }
        
        public InnerNode(UnaryMathOperators op)
        {
            this.subtree = new List<MathNode>();
            this.data = op;
			this.arity = 1;
        }

        public void AddNode(MathNode node)
        {
            this.subtree.Add(node);
        }

        public int numArgs()
        {
           return this.arity;
        }
//        
//        /// <summary>
//        /// Power function for decimals
//        /// </summary>
//        /// <param name="a">
//        /// A <see cref="System.Decimal"/>
//        /// </param>
//        /// <param name="b">
//        /// A <see cref="System.Decimal"/>
//        /// </param>
//        /// <returns>
//        /// A <see cref="System.Decimal"/>
//        /// </returns>
//        private decimal DecimalPower(decimal a, decimal b)
//        {
//        		decimal pow = 1.0m;
//        		while(b>0)
//        		{
//        			pow = pow * a;
//        			b--;
//        		}
//        		return pow;
//        }
        
        /// <summary>
        ///  Builds a function of type StateSnapshot -> double
        /// </summary>
        /// <returns>
        /// A <see cref="AggregateEvaluationFunction"/>
        /// </returns>
		public override AggregateEvaluationFunction ToAggregateEvaluationFunction()
        {
        	// If we have a binary math operator with 2 children
			if (this.data is BinaryMathOperators && this.subtree.Count==2)
			{
				MathNode[] children = this.subtree.ToArray();
				AggregateEvaluationFunction child0 = children[0].ToAggregateEvaluationFunction();
        			AggregateEvaluationFunction child1 = children[1].ToAggregateEvaluationFunction();
				switch ((BinaryMathOperators)this.data)
        			{
        				// Generate a divide function
        				case BinaryMathOperators.Divide:
        					return delegate(StateSnapshot s) { return (child0(s) / child1(s)); };
        				// Generate a minus function
        				case BinaryMathOperators.Minus:
        					return delegate(StateSnapshot s) { return (child0(s) - child1(s)); };
					// Generate a plus function
        				case BinaryMathOperators.Plus:
        					return delegate(StateSnapshot s) { return (child0(s) + child1(s)); };
					// Generate a power function
        				case BinaryMathOperators.Power:
        					return delegate(StateSnapshot s) { return (Math.Pow(child0(s), child1(s))); };
					// Generate a multiply function
        				case BinaryMathOperators.Times:
        					return delegate(StateSnapshot s) { return (child0(s) * child1(s)); };
        			}
			}
			// Case generated by MathML multi-argument operations
			else if (this.data is BinaryMathOperators && this.subtree.Count>2)
			{
				MathNode[] children = this.subtree.ToArray();
				AggregateEvaluationFunction[] childFuns = new AggregateEvaluationFunction[children.Length];
				for(int i=0;i<children.Length;i++)
				{
					childFuns[i] = children[i].ToAggregateEvaluationFunction();
				}
				switch ((BinaryMathOperators)this.data)
				{
					// Generate a divide function
        				case BinaryMathOperators.Divide:
        					return delegate(StateSnapshot s) { 
        						double result = childFuns[0](s);
        						for(int i=1;i<childFuns.Length;i++) {
        							result = result / childFuns[i](s); 
        						}
        						return result;
        					};
        				// Generate a minus function
        				case BinaryMathOperators.Minus:
        					return delegate(StateSnapshot s) { 
							double result = childFuns[0](s);
        						for(int i=1;i<childFuns.Length;i++) {
        							result = result - childFuns[i](s); 
        						}
        						return result;
						};
					// Generate a plus function
        				case BinaryMathOperators.Plus:
        					return delegate(StateSnapshot s) {
        					   double result = childFuns[0](s);
        						for(int i=1;i<childFuns.Length;i++) {
        							result = result + childFuns[i](s); 
        						}
        						return result;
        					};
					// Generate a multiply function
        				case BinaryMathOperators.Times:
        					return delegate(StateSnapshot s) {
							double result = childFuns[0](s);
        						for(int i=1;i<childFuns.Length;i++) {
        							result = result * childFuns[i](s); 
        						}
        						return result;
        					};
        				default:
						return delegate(StateSnapshot s) { return 0.0d; };
        			}
			}
			else if (this.data is UnaryMathOperators && this.subtree.Count==1)
			{
				MathNode[] children = this.subtree.ToArray();
        			AggregateEvaluationFunction child0 = children[0].ToAggregateEvaluationFunction();
        			
				switch ((UnaryMathOperators)this.data)
				{
					// <todo> there is no sec, cosec, cot or arccosh, arsinh, artanh, arsec, arcosed or arcot</todo>
					// Generate an abs function
        				case UnaryMathOperators.Abs:
        					return delegate(StateSnapshot s) { return Math.Abs(child0(s)); };
        				case UnaryMathOperators.Arccos:
        					return delegate(StateSnapshot s) { return Math.Acos(child0(s)); };
        				case UnaryMathOperators.Arcsin:
        					return delegate(StateSnapshot s) { return  Math.Asin(child0(s)); };
        				case UnaryMathOperators.Arctan:
        					return delegate(StateSnapshot s) { return  Math.Atan(child0(s)); };
					case UnaryMathOperators.Ceiling:
        					return delegate(StateSnapshot s) { return Math.Ceiling(child0(s)); };
					case UnaryMathOperators.Cos:
        					return delegate(StateSnapshot s) { return  Math.Cos(child0(s)); };
					case UnaryMathOperators.Cosh:
        					return delegate(StateSnapshot s) { return  Math.Cosh(child0(s)); };
					case UnaryMathOperators.Exp:
        					return delegate(StateSnapshot s) { return Math.Exp(child0(s)); };
					case UnaryMathOperators.Factorial:
						// <todo>factorial function</todo>
        					return delegate(StateSnapshot s) { return 0.0d; };
					case UnaryMathOperators.Floor:
        					return delegate(StateSnapshot s) { return Math.Floor(child0(s)); };
					case UnaryMathOperators.Ln:
        					return delegate(StateSnapshot s) { return Math.Log(child0(s)); };
					case UnaryMathOperators.Log:
        					return delegate(StateSnapshot s) { return Math.Log10(child0(s)); };
        				case UnaryMathOperators.Sin:
        					return delegate(StateSnapshot s) { return Math.Sin(child0(s)); };
					case UnaryMathOperators.Sinh:
        					return delegate(StateSnapshot s) { return Math.Sinh(child0(s)); };
					case UnaryMathOperators.Sqr:
        					return delegate(StateSnapshot s) { double tmp = child0(s); return tmp*tmp; };
					case UnaryMathOperators.Sqrt:
        					return delegate(StateSnapshot s) { return Math.Sqrt(child0(s)); };
					case UnaryMathOperators.Tan:
        					return delegate(StateSnapshot s) { return Math.Tan(child0(s)); };
					case UnaryMathOperators.Tanh:
        					return delegate(StateSnapshot s) { return Math.Tanh(child0(s)); };
				}
			}
			else
			{
				// <todo> Do we need to support booleans?</todo>
				return delegate(StateSnapshot s) { return 0; };
			}
			return delegate(StateSnapshot s) { return 0; };
        }

        /// <summary>
        /// Returns a string representing the approximate units of the formula
        /// </summary>
        /// <returns>A string</returns>
        public override string ApproximateUnits()
        {
            // If we have a binary math operator with 2 children
            if (this.data is BinaryMathOperators && this.subtree.Count == 2)
            {
                MathNode[] children = this.subtree.ToArray();
                string child0 = children[0].ApproximateUnits();
                string child1 = children[1].ApproximateUnits();
                switch ((BinaryMathOperators)this.data)
                {
                    case BinaryMathOperators.Divide:
                        if (child0 == "No units")
                        {
                            if (child1 == "No units")
                            {
                                return "No units";
                            }
                            else
                            {
                                return "1/" + child1;
                            }
                        }
                        else
                        {
                            if (child1 == "No units")
                            {
                                return child0;
                            }
                            else
                            {
                                return child0 + "/" + child1;
                            }
                        }

                    case BinaryMathOperators.Minus:
                        if (child0 == "No units")
                        {
                            return child1;
                        }
                        else if (child1 == "No units")
                        {
                            return child0;
                        }
                        else if (child0 != child1)
                        {
                            return "No units";
                        }
                        else
                        {
                            return child0;
                        }
 
                    case BinaryMathOperators.Plus:
                        if (child0 == "No units")
                        {
                            return child1;
                        }
                        else if (child1 == "No units")
                        {
                            return child0;
                        }
                        else if (child0 != child1)
                        {
                            return "No units";
                        }
                        else
                        {
                            return child0;
                        }

                    case BinaryMathOperators.Power:
                        if (children[1] is NumberLeafNode)
                        {
                            return child0+"^"+children[1].ToString();
                        }
                        else
                        {
                            return child0 + "^" + child1;
                        }

                    case BinaryMathOperators.Times:
                        if (child0 == "No units")
                        {
                            return child1;
                        }
                        else
                        {
                            if (child1 == "No units")
                            {
                                return child0;
                            }
                            else
                            {
                                return child0 + "*" + child1;
                            }
                        }
                }
            }
            
            else if (this.data is UnaryMathOperators && this.subtree.Count == 1)
            {
                MathNode[] children = this.subtree.ToArray();
                return children[0].ApproximateUnits();
            }
            else
            {
                return "No units";
            }
            return "No units";   
        }

        /// <summary>
        /// Builds a function of type StateSnapshot x CellInstance -> double
        /// </summary>
        /// <returns>
        /// A <see cref="CellEvaluationFunction"/>
        /// </returns>
        public override CellEvaluationFunction ToCellEvaluationFunction()
        {
        		// If we have a binary math operator with 2 children
			if (this.data is BinaryMathOperators && this.subtree.Count==2)
			{
				MathNode[] children = this.subtree.ToArray();
				CellEvaluationFunction child0 = children[0].ToCellEvaluationFunction();
        			CellEvaluationFunction child1 = children[1].ToCellEvaluationFunction();
				switch ((BinaryMathOperators)this.data)
        			{
        				// Generate a divide function
        				case BinaryMathOperators.Divide:
        					return delegate(StateSnapshot s, CellInstance c) { return (child0(s, c) / child1(s, c)); };
        				// Generate a minus function
        				case BinaryMathOperators.Minus:
        					return delegate(StateSnapshot s, CellInstance c) { return (child0(s, c) - child1(s, c)); };
					// Generate a plus function
        				case BinaryMathOperators.Plus:
        					return delegate(StateSnapshot s, CellInstance c) { return (child0(s, c) + child1(s, c)); };
					// Generate a power function
        				case BinaryMathOperators.Power:
        					return delegate(StateSnapshot s, CellInstance c) { return (Math.Pow(child0(s, c), child1(s, c))); };
					// Generate a multiply function
        				case BinaryMathOperators.Times:
        					return delegate(StateSnapshot s, CellInstance c) { return (child0(s, c) * child1(s, c)); };
        			}
			}
			// Case generated by MathML multi-argument operations
			else if (this.data is BinaryMathOperators && this.subtree.Count>2)
			{
				MathNode[] children = this.subtree.ToArray();
				CellEvaluationFunction[] childFuns = new CellEvaluationFunction[children.Length];
				for(int i=0;i<children.Length;i++)
				{
					childFuns[i] = children[i].ToCellEvaluationFunction();
				}
				switch ((BinaryMathOperators)this.data)
				{
					// Generate a divide function
        				case BinaryMathOperators.Divide:
        					return delegate(StateSnapshot s, CellInstance c) { 
        						double result = childFuns[0](s, c);
        						for(int i=1;i<childFuns.Length;i++) {
        							result = result / childFuns[i](s, c); 
        						}
        						return result;
        					};
        				// Generate a minus function
        				case BinaryMathOperators.Minus:
        					return delegate(StateSnapshot s, CellInstance c) { 
							double result = childFuns[0](s, c);
        						for(int i=1;i<childFuns.Length;i++) {
        							result = result - childFuns[i](s, c); 
        						}
        						return result;
						};
					// Generate a plus function
        				case BinaryMathOperators.Plus:
        					return delegate(StateSnapshot s, CellInstance c) {
        					   double result = childFuns[0](s, c);
        						for(int i=1;i<childFuns.Length;i++) {
        							result = result + childFuns[i](s, c); 
        						}
        						return result;
        					};
					// Generate a multiply function
        				case BinaryMathOperators.Times:
        					return delegate(StateSnapshot s, CellInstance c) {
							double result = childFuns[0](s, c);
        						for(int i=1;i<childFuns.Length;i++) {
        							result = result * childFuns[i](s, c); 
        						}
        						return result;
        					};
        				default:
						return delegate(StateSnapshot s, CellInstance c) { return 0.0d; };
        			}
			}
			else if (this.data is UnaryMathOperators && this.subtree.Count==1)
			{
				MathNode[] children = this.subtree.ToArray();
        			CellEvaluationFunction child0 = children[0].ToCellEvaluationFunction();
        			
				switch ((UnaryMathOperators)this.data)
				{
					// <todo> there is no sec, cosec, cot or arccosh, arsinh, artanh, arsec, arcosed or arcot</todo>
					// Generate an abs function
        				case UnaryMathOperators.Abs:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Abs(child0(s, c)); };
        				case UnaryMathOperators.Arccos:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Acos(child0(s, c)); };
        				case UnaryMathOperators.Arcsin:
        					return delegate(StateSnapshot s, CellInstance c) { return  Math.Asin(child0(s, c)); };
        				case UnaryMathOperators.Arctan:
        					return delegate(StateSnapshot s, CellInstance c) { return  Math.Atan(child0(s, c)); };
					case UnaryMathOperators.Ceiling:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Ceiling(child0(s, c)); };
					case UnaryMathOperators.Cos:
        					return delegate(StateSnapshot s, CellInstance c) { return  Math.Cos(child0(s, c)); };
					case UnaryMathOperators.Cosh:
        					return delegate(StateSnapshot s, CellInstance c) { return  Math.Cosh(child0(s, c)); };
					case UnaryMathOperators.Exp:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Exp(child0(s, c)); };
					case UnaryMathOperators.Factorial:
						// <todo>factorial function</todo>
        					return delegate(StateSnapshot s, CellInstance c) { return 0.0d; };
					case UnaryMathOperators.Floor:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Floor(child0(s, c)); };
					case UnaryMathOperators.Ln:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Log(child0(s, c)); };
					case UnaryMathOperators.Log:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Log10(child0(s, c)); };
        				case UnaryMathOperators.Sin:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Sin(child0(s, c)); };
					case UnaryMathOperators.Sinh:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Sinh(child0(s, c)); };
					case UnaryMathOperators.Sqr:
        					return delegate(StateSnapshot s, CellInstance c) { double tmp = child0(s, c); return tmp*tmp; };
					case UnaryMathOperators.Sqrt:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Sqrt(child0(s, c)); };
					case UnaryMathOperators.Tan:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Tan(child0(s, c)); };
					case UnaryMathOperators.Tanh:
        					return delegate(StateSnapshot s, CellInstance c) { return Math.Tanh(child0(s, c)); };
				}
			}
			else
			{
				// <todo> Do we need to support booleans?</todo>
				return delegate(StateSnapshot s, CellInstance c) { return 0; };
			}
			return delegate(StateSnapshot s, CellInstance c) { return 0; };
		}
        
        /// <summary>
        /// ToString function for InnerNodes
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/>
        /// </returns>
         public override string ToString()
         {
			// Print representation
			string output = "";
			
			// Get a reader
			Reader.SBMLReader reader = new Reader.SBMLReader();
			
			if (this.arity==2 && this.subtree.Count==2){
				MathNode[] subtreeArray = this.subtree.ToArray();
				output = subtreeArray[0].ToString() + reader.GetOperator(this.data) + subtreeArray[1].ToString();
			} else {
				string operatorString = reader.GetOperator(this.data);
				// Function style () 
				if (operatorString == this.data.ToString())
				{
					output = operatorString + "(";
					// Recurse on children
					if (this.subtree!=null)
					{
						bool tail = false;
						foreach (MathNode m in this.subtree)
						{
							// If we are in the "tail" of the list add delimiter
							if (tail)
							{
								output += ",";
							}
							output += m.ToString();
							tail = true;
						}
					}	
					output += ")";
				}
				// Operator style
				else 
				{
					// Recurse on children
					if (this.subtree!=null)
					{
						bool tail = false;
						foreach (MathNode m in this.subtree)
						{
							// If we are in the "tail" of the list add delimiter
							if (tail)
							{
								output += operatorString;
							}
							output += m.ToString();
							tail = true;
						}
					}
				}
			}
			return output;
		}
        
        /// <summary>
        /// Check the equality of OperatorNodes
        /// </summary>
        /// <param name="o">
        /// A <see cref="System.Object"/>
        /// </param>
        /// <returns>
        /// A <see cref="System.Boolean"/>
        /// </returns>
        public override bool SBMLEquals (object o)
        {
        		if (o is InnerNode)
        		{
        			InnerNode ob = (InnerNode)o;
        			
        			if (ob.data == this.data && ob.arity == this.arity && ob.subtree.Count == this.subtree.Count)
        			{
        				bool equal = true;
        				
        				MathNode[] ob_children = ob.subtree.ToArray();
        				MathNode[] this_children = this.subtree.ToArray();
        				
        				for(int i=0;i<ob.subtree.Count;i++){
        				
        					equal = equal && ob_children[i].SBMLEquals(this_children[i]);
        				}
        				
        				return equal;
        			}
        			else
        			{
        				return false;
        			}
        		}
        		else
        		{
        			return false;
        		}
        }

		/// <summary>
		/// Checks all ReferenceLeafNodes so that they point to their SBase object.
		/// Used to complete a MathTree generated from MathML after it has been parsed and
		/// more about the model is known (such as paramters).
		/// </summary>
		/// <param name="model">
		/// A <see cref="Model"/>
		/// </param>
		public override void SetSBaseReferences(Model model)
		{
			foreach(MathNode node in this.subtree)
			{
				node.SetSBaseReferences(model);
			}
		}
        
    }

}
